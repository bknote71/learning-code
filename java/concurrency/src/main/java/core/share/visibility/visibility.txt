memory visibility(메모리 가시성) 문제
- 값을 사용한 다음 동기화 블록을 빠져나가고 나면 다른 스레드가 변경된 값을 즉시 사용할 수 있게 해야 한다는 뜻이다.

# 가시성
- 단일 스레드만 사용하는 환경이라면 특정 변수에 값을 지정하고 다음번에 해당 변수의 값을 다시 읽어보면, 이전에 저장해뒀던 바로 그 값을 가져올 수 있다.
- 하지만, 여러 스레드에서 앞서거니 뒤서거니 실행된다면 반드시 그렇지 않을 수도 있다.
- 여러 스레드에서 공유되는 특정 변수의 값을 가져갈 때 다른 스레드가 작성한 값을 가져갈 수 있다는 보장이 없다.
- cpu 프로세서의 "캐시" 때문에 발생한다.
--> 이 때문에 메모리상의 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야 한다.

# 재배치(reordering)
- 특정 메서드의 소스 코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제이다.
- 동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다.
- 다시 말하면, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 ‘반드시 이런 순서로 동작할 것이다’ 라고 단정지을 수 없다.

==> 이 때문에 여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용해야 한다.

# Stale Data
- 여러 스레드에서 변수를 사용하는 모든 경우에 동기화를 시켜두지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용핟게 되는 경우가 발생할 수 있다.
- 더 큰 문제는 항상 스테일 데이터를 사용하게 될 때도 있고, 정상적으로 동작하는 경우도 있다는 점이다.
--> 즉 어떻게 될지 모르는 상황이다.

# 단일하지 않은 64비트 연산
- 64비트를 사용하는 숫자형(double 이나 long) 에 volatile 를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성이 있다.
- 자바 메모리 모델은 메모리에서 값을 가져오고 저장하는 연산이 단일해야 한다고 정의하고 있지만,
- volatile 로 지정되지 않은 long 이나 double 형의 64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두 번의 32비트 연산을 사용할 수 있도록 허용하고 있다.
- 따라서 volatile 을 지정하지 않은 64비트 변수(long, double)의 값을 쓰는 기능과 읽는 기능이
- 서로 다른 스레드에서 동작한다면 이전 값과 최신 값에서 각각 32비트를 읽어올 가능성이 생긴다.
- 따라서 volatile 을 지정하지도 않고 락을 사용해 동기화하지도 않은 상태로 64비트 변수(long 이나 double)값을 동시에 여러 스레드에서 사용할 수 있다면 항상 이상한 문제를 만날 가능성이 있다.

# 락과 가시성
- synchronized 로 둘러싸인 코드에서 스레드 A가 사용했던 모든 변수의 값은,
- 같은 락을 사용하는 synchronized 로 둘러싸인 코드를 스레드 B가 실행할 때 안전하게 사용할 수 있다.
- synchronized 블럭 진입 시: 블럭 전까지의 모든 연산이 업데이트 되고, 메인 메모리로부터 데이터를 가져올 수 있다.
- synchronized 블럭 벗어날 시: 메인 메모리로 데이터를 flush 한다.

==>
- 변경 가능한 변수를 여러 개의 스레드에서 동시에 사용한다면,
- 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 다음 스레드가 사용할 수 있게 하기 위해
- 동일한 락을 사용하는 synchronized 블록으로 막아줄 필요가 있다.
- synchronized 구문은 로컬(프로세서) 캐시가 주 메모리와 동일한 값을 가지도록 보장해준다.
- 동기화 되지 않은 메소드의 경우, 다른 스레드에 의해 공유자원이 변경되어도 인지하지 못한다.

# volatile
- 자바 언어에서는 volatile 변수로 약간 다른 형태의 좀 더 약한 동기화 기능을 제공한다.
- volatile 로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다.
- 캐시를 사용하지 않고 메인 메모리에 데이터를 쓰고, 메인 메모리로부터 데이터를 읽는다.
- 특정 변수를 선언할 때 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 ‘이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안 된다’ 고 이해한다.
==> 가시성과 재배치 문제를 해결할 수 있다.

- volatile 로 지정된 변수는 프로세서의 레지스터에 캐시 되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에
- volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다.
- 다만, volatile 변수만 사용해 메모리 가시성을 확보하도록 작성된 코드는 synchronized 로 직접 동기화한 코드보다 훨씬 읽기가 어렵고 따라서 오류가 발생할 가능성도 높다.

volatile 가시성 정리:
- volatile 변수 접근 전까지에 대해 모든 변수들의 update 상황이 메인 메모리에 업데이트 되고, 가시성을 확보한다.
- 그 이후도 마찬가지이다.
- 하지만 모든 변수들의 update 상황을 메인 메모리에도 반영하려면 while문에 어떤 내용이 있어야 메인 메모리로부터 데이터를 가져온다.

재배치 문제는 어떻게 해결할까?
- volatile 변수들의 읽고 쓰기 연산은 JVM에 의해 재배치(reorder) 되지 않는다.
- volatile 이전, 이후의 명령(Instructions)들은 재배치 될 수 있습니다. 하지만 volatile 읽기 혹은 쓰기는 이 연산들과 섞이지 않는다.
- volatile 변수에 대한 읽기 혹은 쓰기 연산 뒤에 실행되는 연산들은 volatile 읽기/쓰기 작업 이후에 실행되는 것을 보장한다!

언제 volatile이 적합할까?
동기화하고자 하는 부분을 명확하게 볼 수 있고, 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용하자.
volatile 변수를 사용하는 적절한 경우는, 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등에 해당한다.
예:  한 쓰래드에서 volatile 변수의 값을 읽고 쓰고, 다른 쓰래드에서는 오직 변수 값을 읽기만 할 경우, 그러면 읽는 쓰래드에서는 volatile 변수의 가장 최근에 쓰여진 값을 보는 것을 보장할 수 있습니다.

volatile 변수는 다음과 같은 상황에서만 사용하는 것이 좋다.
1. 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드 하나만 존재
2. 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않을 때
3. 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우

visibility는 너무 애매한 것 같다.
- 따라서 가시성을 확보할 상태 변수에 대하여 명확하게 volatile이나 synchronized getter, setter를 설정해야겠다.