스레드 한정이란?
- 특정 객체 혹은 특정 작업(ex. 쓰기) 특정 스레드에 한정/제한하는 것
- 특정 객체를 단일 스레드에서만 활용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없다.
- 이처럼 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안정성을 확보할 수 있다.
==>
 why? 여러 스레드가 특정 객체에 접근하여 발생하는 race condition 을 제거하기 때문에

예)
1. 스윙:
- 스윙의 화면 컴포넌트와 데이터 모델 객체는 스레드에 안전하지 않지만, 스윙 이벤트 처리 스레드에 컴포넌트와 모델을 한정시켜 스레드 안정성을 확보하고 있다.
2. jdbc connection pool (hikariCP)
- threadlist, sharedList(compareAndSet), SynchronizedQueue
- threadlist만 스레드 한정^^

언어적인 차원에서 임의의 객체를 특정 스레드에 한정시키는 기능은 제공하지 않기 때문에
스레드 한정 기법은 프로그램을 처음 설계하는 과정부터 함께 다뤄야 하며, 프로그램을 구현하는 과정 내내 한정 기법을 계속해서 적용해야 한다.

# 주먹구구식 스레드 한정: 기능(= 작업, 메서드)을 특정 스레드에 제한
- 특정 모듈의 기능을 단일 스레드로 동작하도록 구현한다면,
- 언어적인 지원 없이 직접 구현한 스레드 한정 기법에서 나타날 수 있는 오류의 가능성을 최소화할 수 있다.
(특정 모듈을 단일 스레드로 동작하도록 구현하면 데드락을 미연에 방지할 수 있다는 장점이 있다)

읽기와 쓰기가 모두 가능한 volatile 변수를 공유해 사용할 때에는 특정 단일 스레드에서만 쓰기 작업을 하도록 구현해야 안전하다.
이런 경우 경쟁 조건을 막기 위해 ‘변경(쓰기)’ 작업은 특정 스레드 한 곳에서만 할 수 있도록 제한해야 하고,
읽기 작업이 가능한 다른 모든 스레드는 volatile 변수의 특성상 가장 최근에 업데이트된 값을 정확하게 읽어갈 수 있다.

==>
- 즉 race condition을 발생시킬 수 있는 쓰기 작업만 특정 스레드에 한정
if(instance == null) {
    (instance == null)
    --> true 임을 항상 만족시킬 수는 없다.
}
- 이렇게 임시방편적인 주먹구구식 스레드 한정 기법은 안정성을 완벽하게 보장할 수 있는 방법은 아니기 때문에 제한적으로 사용하고,
- 가능하다면 스택 한정이나 ThreadLocal 클래스 등의 좀 더 안전한 스레드 한정 기법을 사용하자

# 스택 한정
- "스택"(메모리) 자체가 스레드 제한적이기 때문에
- 객체를 스택, 즉 로컬 변수를 통해서만 사용하도록 하는 것을 스레드 한정이고 할 수 있다.
- 로컬 변수 = 스레드에 한정
- 즉, 로컬 변수는 현재 실행 중인 스레드 내부의 스택에만 존재하기 때문이며, 스레드 내부의 스택은 외부 스레드에서 물론 볼 수 없다.
- 하지만 로컬 변수를 사용한다 하더라도 항상 스레드 안전한 것은 아니다.

중요:
- 객체형 변수가 스택 한정 상태를 유지할 수 있게 하려면 해당 객체에 대한 참조가 외부로 유출되지 않도록 개발자가 주의를 기울여야 한다.
- 스레드 한정, 말 그대로 로컬 변수를 다른 스레드로부터 참조되는 것을 막아야 한다.
- 참고: 스레드에 안전하지 않은 객체라 해도 특정 스레드 내부에서만 동작한다면 동기화 문제가 없기 때문에 안전하다.

# ThreadLocal
- 특정한 스레드 내에서만 "전역적으로 접근"이 가능한 변수이다.
- 변경 가능한 싱글턴이나 전역 변수 등을 기반으로 설계되어 있는 구조에서 변수가 임의로 공유되는 상황을 막기 위해 사용되는 경우가 많다.
- 개념적으로 본다면 ThreadLocal 클래스는 Map<Thread, T> 라는 자료 구조로 구성되어 있고, Map<Thread, T>에 스레드별 값을 보관한다고 생각할 수 있겠다.

만약 원래 단일 스레드에서 동작하던 기능을 멀티스레드 환경으로 구성해야 할 때,
그 의미에 따라 다르지만 스레드 내에서 공유된 전역 변수를 ThreadLocal 을 활용하도록 변경하면 스레드 안정성을 보장할 수 있다

사용 예) hikariCP에서의 threadlist

이렇게 편리하긴 하지만, 전역 변수가 아니면서도 전역 변수처럼 동작하기 때문에 프로그램 구조상 전역 변수를 남발하는 결과를 가져올 수도 있고,
따라서 메서드에 당연히 인자로 넘겨야할 값을 ThreadLocal 을 통해 뒤로 넘겨주는 방법을 사용하면서 프로그램의 구조가 허약해질 가능성도 높다.
- 즉 굳이 안써도 되는 상황까지 사용하지 말자!

ThreadLocal 활용
1. ThreadLocal 연산(e.g. get, set, remove, ..) 연산은 스레드 안정적이다.
2. Holder 를 활용하면 전역적으로 사용할 수 있다.

주의점
- 쓰레드 풀을 사용하는 환경에서는 반드시 사용을 마치고 clear(remove)를 해줘야 한다.
- 쓰레드 생성비용의 오버헤드 때문에 쓰레드 풀은 기존의 쓰레드를 재사용 한다.
- 만약 쓰레드를 다 사용하고 clear 하지 않는다면 쓰레드가 재사용 될 때 이전의 ThreadLocal 변수를 참조하게 된다.
- 반드시 clear 작업이 필요하다.
